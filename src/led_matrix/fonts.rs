//! Font definitions for use with 8x8 LED matrix displays.

/// Fallback 8x8 glyph used when a character is not found in the font map.
///
/// This pattern resembles a question mark and is shown for unsupported or unknown characters.
///
/// Each byte represents one row in the 8x8 grid, with bits set to 1 for lit pixels.
pub const FONT8X8_UNKNOWN: [u8; 8] = [
    // Question mark : ?
    0b00000000, 0b00111100, 0b01000010, 0b00000010, 0b00001100, 0b00000000, 0b00001100, 0b00000000,
];

/// A simple 8x8 font map
pub const FONT8X8: &[([u8; 8], char)] = &[
    (
        [
            0b00000000, 0b00111100, 0b01100110, 0b01100110, 0b01111110, 0b01100110, 0b01100110,
            0b01100110,
        ],
        'A',
    ),
    (
        [
            0b01111000, 0b01001000, 0b01001000, 0b01110000, 0b01001000, 0b01000100, 0b01000100,
            0b01111100,
        ],
        'B',
    ),
    (
        [
            0b00000000, 0b00011110, 0b00100000, 0b01000000, 0b01000000, 0b01000000, 0b00100000,
            0b00011110,
        ],
        'C',
    ),
    (
        [
            0b00000000, 0b00111000, 0b00100100, 0b00100010, 0b00100010, 0b00100100, 0b00111000,
            0b00000000,
        ],
        'D',
    ),
    (
        [
            0b00000000, 0b00111100, 0b00100000, 0b00111000, 0b00100000, 0b00100000, 0b00111100,
            0b00000000,
        ],
        'E',
    ),
    (
        [
            0b00000000, 0b00111100, 0b00100000, 0b00111000, 0b00100000, 0b00100000, 0b00100000,
            0b00000000,
        ],
        'F',
    ),
    (
        [
            0b00000000, 0b00111110, 0b00100000, 0b00100000, 0b00101110, 0b00100010, 0b00111110,
            0b00000000,
        ],
        'G',
    ),
    (
        [
            0b00000000, 0b00100100, 0b00100100, 0b00111100, 0b00100100, 0b00100100, 0b00100100,
            0b00000000,
        ],
        'H',
    ),
    (
        [
            0b00000000, 0b00111000, 0b00010000, 0b00010000, 0b00010000, 0b00010000, 0b00111000,
            0b00000000,
        ],
        'I',
    ),
    (
        [
            0b00000000, 0b00011100, 0b00001000, 0b00001000, 0b00001000, 0b00101000, 0b00111000,
            0b00000000,
        ],
        'J',
    ),
    (
        [
            0b00000000, 0b00100100, 0b00101000, 0b00110000, 0b00101000, 0b00100100, 0b00100100,
            0b00000000,
        ],
        'K',
    ),
    (
        [
            0b00000000, 0b00100000, 0b00100000, 0b00100000, 0b00100000, 0b00100000, 0b00111100,
            0b00000000,
        ],
        'L',
    ),
    (
        [
            0b00000000, 0b00000000, 0b01000100, 0b10101010, 0b10010010, 0b10000010, 0b10000010,
            0b00000000,
        ],
        'M',
    ),
    (
        [
            0b00000000, 0b00100010, 0b00110010, 0b00101010, 0b00100110, 0b00100010, 0b00000000,
            0b00000000,
        ],
        'N',
    ),
    (
        [
            0b00000000, 0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b00111100,
            0b00000000,
        ],
        'O',
    ),
    (
        [
            0b00000000, 0b00111000, 0b00100100, 0b00100100, 0b00111000, 0b00100000, 0b00100000,
            0b00000000,
        ],
        'P',
    ),
    (
        [
            0b00000000, 0b00111100, 0b01000010, 0b01000010, 0b01000010, 0b01000110, 0b00111110,
            0b00000001,
        ],
        'Q',
    ),
    (
        [
            0b00000000, 0b00111000, 0b00100100, 0b00100100, 0b00111000, 0b00100100, 0b00100100,
            0b00000000,
        ],
        'R',
    ),
    (
        [
            0b00000000, 0b00111100, 0b00100000, 0b00111100, 0b00000100, 0b00000100, 0b00111100,
            0b00000000,
        ],
        'S',
    ),
    (
        [
            0b00000000, 0b11111000, 0b00100000, 0b00100000, 0b00100000, 0b00100000, 0b00100000,
            0b00000000,
        ],
        'T',
    ),
    (
        [
            0b00000000, 0b01000010, 0b01000010, 0b01000010, 0b01000010, 0b00100100, 0b00011000,
            0b00000000,
        ],
        'U',
    ),
    (
        [
            0b00000000, 0b00100010, 0b00100010, 0b00100010, 0b00010100, 0b00010100, 0b00001000,
            0b00000000,
        ],
        'V',
    ),
    (
        [
            0b00000000, 0b10000010, 0b10010010, 0b01010100, 0b01010100, 0b00101000, 0b00000000,
            0b00000000,
        ],
        'W',
    ),
    (
        [
            0b00000000, 0b01000010, 0b00100100, 0b00011000, 0b00011000, 0b00100100, 0b01000010,
            0b00000000,
        ],
        'X',
    ),
    (
        [
            0b00000000, 0b01000100, 0b00101000, 0b00010000, 0b00010000, 0b00010000, 0b00010000,
            0b00000000,
        ],
        'Y',
    ),
    (
        [
            0b00000000, 0b00111100, 0b00000100, 0b00001000, 0b00010000, 0b00100000, 0b00111100,
            0b00000000,
        ],
        'Z',
    ),
];

pub(crate) fn get_char_bitmap(c: char) -> Option<[u8; 8]> {
    FONT8X8
        .iter()
        .find_map(|(bitmap, ch)| if *ch == c { Some(*bitmap) } else { None })
}
